##1、广播的分类以及使用场景

广播的类型主要分为:



- 普通广播


- 系统广播


- 无序广播


- 有序广播


- 粘性广播


- App应用内广播

### 普通广播
 普通广播对于多个接收者来说是完全异步的，通常每个接收者都无需等待即可以接收到广播，接收者相互之间不会有影响。对于这种广播，接收者无法终止广播，即无法阻止其他接收者的 接收动作

### 系统广播
Android中内置了很多系统广播：只要涉及到手机的基本操作(开机、网络变化、插入耳机等),都可以通过发送系统广播来监听变化，通过发送对应的intent-filter(包括action)

**注：**当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播


### 无序广播

无序广播即为我们平时经常使用的广播，其主要是通过public abstract void sendBroadcast (Intent intent)方法进行发送，并通过intent传递数据。

无序广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。
无序广播不可以被拦截，不可以被终止，不可以被修改，无序广播任何接收者只要匹配条件都可以接收到，无优先级问题。

### 有序广播

有序广播比较特殊，每次发送广播会先发送到优先者高的地方，然后再通过优先者高的往低的发送，优先者高的可以截断广播，那么之后的接收者就接收不到广播了，可以在广播注册时使用intent-filter里面的android: priority=”xxx”去解决或在java代码中用setPriority（xxx）来设置。



### 粘性广播

粘性消息在发送后就一直存在于系统的消息容器里面，等待对应的处理器去处理，如果暂时没有处理器处理这个消息则一直在消息容器里面处于等待状态，粘性广播的Receiver如果被销毁，那么下次重建时会自动接收到消息数据。




### App内应用广播

1. App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。
2. 相比于全局广播（普通广播），App应用内广播优势体现在：安全性高 & 效率高



 具体使用1 - 将全局广播设置成局部广播

1. 注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；
2. 在广播发送和接收时，增设相应权限permission，用于权限验证；
3. 发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。
通过intent.setPackage(packageName)指定包名



具体使用2 - 使用封装好的LocalBroadcastManager类

使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例

> 注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册

## 2.广播的两种注册方式的区别
动态注册和静态注册两种


###区别：
动态注册是在代码中注册

静态注册是在清单文件中注册

在代码中进行注册后，当应用程序关闭后，就不再进行监听。我们读知道，应用程序是否省电，决定了该应用程序的受欢迎程度，所以，对于那些没必要在程序关闭后仍然进行监听的Receiver，在代码中进行注册，无疑是一个明智的选择。


在AndroidManifest中进行注册后，不管改应用程序是否处于活动状态，都会进行监听，比如某个程序时监听 内存的使用情况的，当在手机上安装好后，不管改应用程序是处于什么状态，都会执行改监听方法中的内容。


##4、本地广播和全局广播的区别

由于之前的广播都是全局的，所有应用程序都可以接收到，这样就很 容易会引起安全性 的问题，比如说我们发送一些携带关键性数据的广播有可能 被其他的应用程序截获 ，或者其他的程序不停地 向我们的广播接收器里发送各种垃圾广播 。

为了能够简单地解决广播的安全性问题，Android引入了一套 本地广播机制 ，使用这个机制发出的广播 只能够在应用程序的内部进行传递 ，并且 广播接收器也只能接收来自应用程序发出的广播 ，这样所有的安全性问题就都不存在了。

1注册方式不同
2安全性不同（一个内，一个外）
 
（1）本地广播无法通过静态注册来接收，相比起系统全局广播更加高效

（2）在广播中启动activity的话，需要为intent加入FLAG _ACTIVITY _NEW _TASK的标记，不然会报错，因为需要一个栈来存放新打开的activity。

（3）广播中弹出AlertDialog的话，需要设置对话框的类型为:TYPE _SYSTEM _ALERT不然是无法弹出的。
